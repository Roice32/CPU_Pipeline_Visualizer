Have consistent `const`s.
Have relevant access modifiers.

    Branch Predictor:
- timings?
    - 1 tick? this leads to massive workload queues on IC compared to BP
    - when a jump comes, should BP itself burn the invalid sent IPs in the queue?
    - should BP respect the 1-tick delay between it and EX?

- wired to IC & EX how?
    - IC <-> BP: addr
        - BP -> IC if BP takes from IC the job of keeping an internalIP
    - EX -> BP: { instrAddr, jumpToAddr, conditional, taken, signalForWrongPrediction }

- what IP it relies on?
    - maybe seek addresses of jumps within the last FW passed by IC / itself to DE

- how does IC work in regards to BP?
    - IC -> BP: addr of FW sent to DE (if bidirectional)
    - BP -> IC: addr of next FW
    - IC still starts the whole program from #fff0 (or BP starts from there)

- should it also inform DE of jumps?
    - in DE: if (addrReceivedFromIC != cacheStartAddr + 2 * storedWords) then consider jump + discard
        - but IC needs to let DE know the word within that FW where to start (so IC must receive addr aligned to next instruction not next FW)

- what does it store internally?
    - hashmap<jumpInstrAddr, { jumpToAddr, conditional, timesTaken? }>

- the algorithm itself?
    (backward-yes-forward-no sounds good, but it doesn't really have anything to do with the whole cache-thing)

- what was that threshold all about?
    - was it a minimal amount of jumps until BP assumes that conditional jump will be taken again?

- then does DE still signal IP change to IC?
    - ~no, EX discards everything until BP puts things back on track when failing a prediction
        - would undefined behavior from residual instructions matching jump addr occur?

- what strategy should BP use in regards to its cache?
    - LRU, favoring keeping unconditional jumps in cache when possible?

- as for logging, I suppose it just prints its predictions when reaching a jump in cache
    - also signals from EX regarding wrong predictions?

Time differences with vs. without caches:
    - basicTest.hex: ~1k vs ~630 ticks
    - repeated_load_store.hex: ~21k vs. ~31k
    - recursion.hex: ~31k vs. ~41k
